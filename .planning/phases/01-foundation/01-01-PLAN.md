---
phase: 01-foundation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/traits/types.ts
  - src/lib/traits/validation.ts
  - src/lib/traits/generation.ts
  - src/lib/traits/colorHarmony.ts
  - src/__tests__/lib/traits/generation.test.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Same pet ID always produces identical visual traits across all environments"
    - "Generated colors are aesthetically pleasing with no muddy or clashing combinations"
    - "Rarity distribution matches expected percentages (common 70%, uncommon 20%, rare 8%, legendary 2%)"
    - "System produces 48,000+ unique visual combinations from trait categories"
    - "Trait data validates against schema at runtime with clear error messages"
  artifacts:
    - path: "src/lib/traits/types.ts"
      provides: "PetTraits interface and HSLColor type"
      exports: ["PetTraits", "HSLColor", "PatternType", "AccessoryType", "BodySize", "ExpressionType", "RarityTier"]
    - path: "src/lib/traits/validation.ts"
      provides: "Zod schemas for runtime trait validation"
      exports: ["PetTraitsSchema", "HSLColorSchema"]
    - path: "src/lib/traits/generation.ts"
      provides: "Deterministic trait generation using seeded PRNG"
      exports: ["generatePetTraits"]
    - path: "src/lib/traits/colorHarmony.ts"
      provides: "HSL color generation with harmony constraints"
      exports: ["generateHarmonizedColor", "generateComplementaryColor", "hslToString", "validateColorHarmony"]
    - path: "src/__tests__/lib/traits/generation.test.ts"
      provides: "Comprehensive test suite for trait generation"
      min_lines: 80
  key_links:
    - from: "src/lib/traits/generation.ts"
      to: "seedrandom"
      via: "import seedrandom from 'seedrandom'"
      pattern: "seedrandom"
    - from: "src/lib/traits/generation.ts"
      to: "src/lib/traits/colorHarmony.ts"
      via: "import for color generation"
      pattern: "import.*colorHarmony"
    - from: "src/lib/traits/generation.ts"
      to: "src/lib/traits/types.ts"
      via: "import PetTraits type"
      pattern: "import.*PetTraits.*types"
    - from: "src/lib/traits/validation.ts"
      to: "zod"
      via: "Zod schema definitions"
      pattern: "z\\.object"
---

<objective>
Build the deterministic pet trait generation system with seeded PRNG, HSL color harmony, weighted rarity distribution, and runtime validation.

Purpose: This is the computational core of the visual pet system. Every pet's unique appearance flows from this generation engine. Determinism (same pet ID = same traits everywhere) and aesthetic quality (no ugly color combos) are non-negotiable requirements.

Output: Tested, type-safe trait generation engine that accepts a pet ID string and returns a validated PetTraits object with body color, pattern, accessory, size, expression, and rarity.
</objective>

<execution_context>
@/Users/tarikstafford/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tarikstafford/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@src/lib/genetics.ts
@prisma/schema.prisma
</context>

<feature>
  <name>Deterministic Pet Trait Generation</name>
  <files>
    src/lib/traits/types.ts
    src/lib/traits/validation.ts
    src/lib/traits/generation.ts
    src/lib/traits/colorHarmony.ts
    src/__tests__/lib/traits/generation.test.ts
    package.json
  </files>
  <behavior>
    The trait generation system must satisfy these testable behaviors:

    **Determinism:**
    - generatePetTraits("pet-abc-123") called twice returns deep-equal objects
    - generatePetTraits("pet-abc-123") and generatePetTraits("pet-xyz-456") return different objects
    - Determinism holds across multiple sequential calls (no shared state leaking)

    **Color Harmony:**
    - All generated body colors have saturation 50-90% and lightness 25-75%
    - Pattern colors are complementary to body color (hue offset ~180 degrees +/- 15)
    - validateColorHarmony() rejects muddy combos (S < 30 && L 40-60)
    - hslToString({h:120, s:70, l:50}) returns "hsl(120, 70%, 50%)"

    **Rarity Distribution (over 10,000 samples):**
    - Common: 65-75% (target 70%)
    - Uncommon: 15-25% (target 20%)
    - Rare: 3-13% (target 8%)
    - Legendary: 0-7% (target 2%)

    **Combination Count:**
    - At least 8 body color hue buckets (45-degree ranges)
    - 4+ pattern types (none, striped, spotted, gradient) with 6+ colors each
    - 5+ accessories (none, horns, wings, crown, collar)
    - 3+ body sizes (small, medium, large)
    - 5+ expressions (happy, neutral, curious, mischievous, sleepy)
    - Total unique combos: 8 * 4 * 8 * 5 * 3 * 5 >= 48,000 (with continuous color space, effectively infinite)

    **Validation:**
    - PetTraitsSchema.parse(validTraits) succeeds
    - PetTraitsSchema.parse({}) throws ZodError
    - PetTraitsSchema.parse({bodyColor: {h: 400, s: 50, l: 50}}) throws (h > 360)

    **Weighted Selection:**
    - weightedChoice(rng, {a: 0.9, b: 0.1}) returns 'a' ~90% of the time over 1000 samples
  </behavior>
  <implementation>
    **Step 0: Install seedrandom**
    Run `npm install seedrandom && npm install --save-dev @types/seedrandom` in project root.

    **Step 1 (RED): Write tests first in src/__tests__/lib/traits/generation.test.ts**
    Create test file covering all behaviors listed above. Tests MUST fail initially because the source files don't exist yet. Use vitest (already configured). Import from `@/lib/traits/generation`, `@/lib/traits/colorHarmony`, `@/lib/traits/validation`, `@/lib/traits/types`.

    Test structure:
    - describe('Trait Determinism')
      - it('generates identical traits for same pet ID')
      - it('generates different traits for different pet IDs')
      - it('maintains determinism across sequential calls')
    - describe('Color Harmony')
      - it('constrains body color saturation to 50-90%')
      - it('constrains body color lightness to 25-75%')
      - it('generates complementary pattern colors')
      - it('converts HSL to CSS string correctly')
      - it('rejects muddy color combinations')
    - describe('Rarity Distribution')
      - it('matches expected percentages over 10,000 samples')
    - describe('Trait Validation')
      - it('validates correct trait objects')
      - it('rejects empty objects')
      - it('rejects out-of-range HSL values')
    - describe('Weighted Selection')
      - it('respects weight proportions over 1000 samples')

    Run `npx vitest run src/__tests__/lib/traits/generation.test.ts` -- tests MUST fail.

    **Step 2 (GREEN): Implement the generation system**

    Create `src/lib/traits/types.ts`:
    - HSLColor interface: { h: number (0-360), s: number (0-100), l: number (0-100) }
    - PatternType: 'none' | 'striped' | 'spotted' | 'gradient'
    - AccessoryType: 'none' | 'horns' | 'wings' | 'crown' | 'collar'
    - BodySize: 'small' | 'medium' | 'large'
    - ExpressionType: 'happy' | 'neutral' | 'curious' | 'mischievous' | 'sleepy'
    - RarityTier: 'common' | 'uncommon' | 'rare' | 'legendary'
    - PetTraits interface with all fields including traitVersion: 1

    Create `src/lib/traits/validation.ts`:
    - HSLColorSchema (z.object with min/max constraints on h/s/l)
    - PetTraitsSchema (full schema matching PetTraits interface)
    - Export type PetTraits = z.infer<typeof PetTraitsSchema> -- BUT prefer the manual interface from types.ts for code clarity; use the schema for runtime validation only

    Create `src/lib/traits/colorHarmony.ts`:
    - generateHarmonizedColor(rng, constraints) -- generates HSL within S: 50-90, L: 25-75
    - generateComplementaryColor(baseColor, rng) -- rotates hue ~180 +/- 15 degrees
    - hslToString(color) -- returns CSS hsl() string
    - validateColorHarmony(colors[]) -- checks no muddy combos

    Create `src/lib/traits/generation.ts`:
    - Import seedrandom (default import)
    - weightedChoice<T>(rng, weights) helper function (cumulative distribution)
    - getRarityTier(rng) -- common 70%, uncommon 20%, rare 8%, legendary 2%
    - generatePetTraits(petId: string): PetTraits -- PURE function, only depends on petId seed
    - Rarity influences pattern probability: legendaries get gradient more often, common gets 'none' more often
    - Accessories weighted by rarity: legendaries can get crown, common gets none/collar
    - Add ACCESSORY_WEIGHTS, PATTERN_WEIGHTS, SIZE_WEIGHTS, EXPRESSION_WEIGHTS as const objects

    IMPORTANT: Do NOT use Math.random() anywhere. ALL randomness must flow through the seeded rng instance.
    IMPORTANT: The generation function must be pure -- no Date.now(), no external API calls, no shared mutable state.
    IMPORTANT: Each call to generatePetTraits creates a NEW seedrandom instance from the petId, ensuring determinism.

    Run tests -- ALL must pass.

    **Step 3 (REFACTOR if needed):** Clean up, add JSDoc comments, ensure exports are clean. Run tests again to confirm still passing.
  </implementation>
</feature>

<verification>
1. `npx vitest run src/__tests__/lib/traits/generation.test.ts` -- all tests pass
2. `npx tsc --noEmit` -- no TypeScript errors
3. Determinism spot-check: run generation twice in test with same ID, deep equality confirmed
4. Distribution check: 10,000 sample test passes within tolerance bounds
</verification>

<success_criteria>
- seedrandom installed and typed
- PetTraits type system defined with all 6 trait categories + rarity
- Seeded generation produces identical output for same pet ID
- Color harmony constraints prevent muddy/clashing colors
- Rarity distribution matches 70/20/8/2 within 5% tolerance
- Zod validation catches invalid trait data at runtime
- All tests pass, TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
