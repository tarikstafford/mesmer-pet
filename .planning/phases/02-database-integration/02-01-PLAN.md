---
phase: 02-database-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/scripts/backfill-pet-traits.ts
autonomous: true

must_haves:
  truths:
    - "Pet table has a traits column that stores JSON data"
    - "All existing pets in database have valid trait JSON assigned (zero null traits)"
    - "Migration is reversible (traits column can be dropped cleanly)"
    - "Backfill script is idempotent (running twice does not corrupt data)"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Pet model with optional Json traits field"
      contains: "traits"
    - path: "prisma/scripts/backfill-pet-traits.ts"
      provides: "Data migration script for existing pets"
      min_lines: 40
  key_links:
    - from: "prisma/scripts/backfill-pet-traits.ts"
      to: "src/lib/traits/generation.ts"
      via: "imports generatePetTraits"
      pattern: "generatePetTraits"
    - from: "prisma/scripts/backfill-pet-traits.ts"
      to: "src/lib/traits/validation.ts"
      via: "imports PetTraitsSchema for validation"
      pattern: "PetTraitsSchema"
---

<objective>
Add traits JSON column to Pet table via Prisma migration and backfill all existing pets with deterministic visual traits.

Purpose: Existing pets need visual traits stored in the database so they render with unique SVG appearances. This is the data foundation that the creation flow update and all display contexts depend on.
Output: Updated Prisma schema with traits field, applied migration, backfill script, all existing pets populated with validated traits.
</objective>

<execution_context>
@/Users/tarikstafford/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tarikstafford/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-integration/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@prisma/schema.prisma
@src/lib/traits/generation.ts
@src/lib/traits/validation.ts
@src/lib/prisma.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add traits column to Pet model and create Prisma migration</name>
  <files>prisma/schema.prisma</files>
  <action>
    1. Add `traits Json?` field to the Pet model in `prisma/schema.prisma`, placed after the `parent2Id` field and before the timestamps section. Add a comment: `// Visual appearance traits (JSON) - generated by trait system`. Keep it optional (`Json?`) to avoid the known Prisma SQLite JSON default value bug (prisma/prisma#26571). Do NOT add a `@default()` decorator.

    2. Run `npx prisma migrate dev --create-only --name add_pet_visual_traits` to generate the migration SQL file without applying it.

    3. Verify the generated migration SQL file in `prisma/migrations/` contains `ALTER TABLE "Pet" ADD COLUMN "traits" TEXT` (SQLite stores JSON as TEXT). If Prisma generated something different (e.g., a full table recreation), edit the SQL to use the simpler ALTER TABLE approach since we're just adding a nullable column.

    4. Apply the migration with `npx prisma migrate dev`.

    5. Regenerate the Prisma client with `npx prisma generate` (this should happen automatically with migrate dev, but verify).

    Avoid: Do NOT make the traits column required. Do NOT add a default value. Do NOT modify any other fields in the Pet model.
  </action>
  <verify>
    1. `npx prisma migrate status` shows no pending migrations
    2. `npx prisma db execute --stdin <<< "SELECT COUNT(*) FROM pragma_table_info('Pet') WHERE name = 'traits'"` returns 1
    3. TypeScript compilation succeeds: `npx tsc --noEmit --pretty 2>&1 | head -20` (no new errors)
  </verify>
  <done>Pet table has a nullable `traits` column (TEXT type in SQLite), migration is tracked in Prisma migration history, Prisma Client types include `traits: Prisma.JsonValue | null` on the Pet model.</done>
</task>

<task type="auto">
  <name>Task 2: Create and run idempotent backfill script for existing pets</name>
  <files>prisma/scripts/backfill-pet-traits.ts</files>
  <action>
    1. Create `prisma/scripts/` directory if it doesn't exist.

    2. Create `prisma/scripts/backfill-pet-traits.ts` with:
       - Import `PrismaClient` from `@prisma/client`, `PrismaLibSql` from `@prisma/adapter-libsql`
       - Import `generatePetTraits` from `../../src/lib/traits/generation`
       - Import `PetTraitsSchema` from `../../src/lib/traits/validation`
       - Create a standalone Prisma client instance (do NOT import the singleton from src/lib/prisma.ts -- this is a standalone script). Use the same adapter pattern:
         ```
         const adapter = new PrismaLibSql({ url: process.env.DATABASE_URL || 'file:./prisma/dev.db' })
         const prisma = new PrismaClient({ adapter })
         ```
       - Main `backfillPetTraits()` async function that:
         a. Fetches all pets where `traits` is null: `prisma.pet.findMany({ where: { traits: null }, select: { id: true, name: true } })`
         b. If no pets found, log "All pets already have traits - nothing to backfill" and return
         c. Log count: `Found {N} pets without traits`
         d. Wrap all updates in `prisma.$transaction()` for atomicity
         e. For each pet: call `generatePetTraits(pet.id)`, validate with `PetTraitsSchema.parse()`, update pet with `tx.pet.update({ where: { id: pet.id }, data: { traits: validated } })`
         f. Log progress for each pet: `Generated traits for {name} ({id}) - rarity: {rarity}`
         g. After transaction: log `Backfill complete: {N} pets updated`
       - Run with `.catch()` logging errors and calling `process.exit(1)`, `.finally()` calling `prisma.$disconnect()`

    3. Run the script: `npx tsx prisma/scripts/backfill-pet-traits.ts`

    4. Verify idempotency by running the script again -- it should report "All pets already have traits" and make no changes.

    Avoid: Do NOT use Math.random() anywhere. Do NOT import from `@/lib/prisma` (path aliases don't work in standalone scripts). Do NOT skip Zod validation before saving.
  </action>
  <verify>
    1. Script runs without errors: `npx tsx prisma/scripts/backfill-pet-traits.ts`
    2. Zero pets with null traits: `npx prisma db execute --stdin <<< "SELECT COUNT(*) as missing FROM Pet WHERE traits IS NULL"` returns 0
    3. All traits are valid JSON: `npx prisma db execute --stdin <<< "SELECT COUNT(*) as valid FROM Pet WHERE json_valid(traits) = 1"` matches total pet count
    4. Idempotent: Running script again shows "All pets already have traits"
    5. Deterministic: Traits for a given pet ID match `generatePetTraits(petId)` output (same seed = same traits)
  </verify>
  <done>All existing pets in the database have valid, Zod-validated trait JSON. The backfill script is idempotent and can be safely re-run. Traits are deterministic -- regenerating from the same pet ID produces identical results.</done>
</task>

</tasks>

<verification>
1. `npx prisma migrate status` -- no pending migrations
2. `npx prisma db execute --stdin <<< "SELECT COUNT(*) FROM Pet WHERE traits IS NULL"` -- returns 0
3. `npx tsx prisma/scripts/backfill-pet-traits.ts` -- reports nothing to backfill (idempotent)
4. Existing tests still pass: `npx vitest run --reporter=verbose 2>&1 | tail -20`
</verification>

<success_criteria>
- Pet table has `traits` JSON column (nullable)
- Migration tracked in Prisma migration history
- All existing pets have valid trait JSON (zero nulls)
- Backfill script is idempotent and deterministic
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-integration/02-01-SUMMARY.md`
</output>
