---
phase: 05-performance-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/pet-svg/AnimatedPetSVG.tsx
  - src/hooks/useFPSMonitor.ts
  - src/__tests__/performance/render-benchmark.spec.ts
autonomous: true

must_haves:
  truths:
    - "Single pet render completes in under 16ms (60fps budget)"
    - "Trait generation completes in under 10ms per pet"
    - "10 simultaneous pets render without exceeding 16ms per frame"
    - "Page load with 10+ visible pets adds less than 100ms overhead"
  artifacts:
    - path: "src/components/pet-svg/AnimatedPetSVG.tsx"
      provides: "React.memo-wrapped AnimatedPetSVG preventing unnecessary re-renders"
      contains: "React.memo"
    - path: "src/hooks/useFPSMonitor.ts"
      provides: "Development-only FPS monitoring hook"
      exports: ["useFPSMonitor"]
    - path: "src/__tests__/performance/render-benchmark.spec.ts"
      provides: "Performance benchmark test suite for PERF-01 through PERF-05"
      contains: "Profiler"
  key_links:
    - from: "src/__tests__/performance/render-benchmark.spec.ts"
      to: "src/components/pet-svg/AnimatedPetSVG.tsx"
      via: "React Profiler wrapping component render"
      pattern: "Profiler.*AnimatedPetSVG"
    - from: "src/__tests__/performance/render-benchmark.spec.ts"
      to: "src/lib/traits/generation.ts"
      via: "Direct timing of generatePetTraits"
      pattern: "generatePetTraits"
---

<objective>
Add React.memo optimization to AnimatedPetSVG, create FPS monitoring hook, and build automated performance benchmark test suite validating PERF-01 through PERF-05.

Purpose: Establish measurable performance baselines and prevent regressions for the pet rendering system. AnimatedPetSVG is currently NOT memoized (unlike PetSVG which uses React.memo), meaning parent re-renders cause unnecessary animation wrapper re-renders.

Output: Memoized AnimatedPetSVG component, useFPSMonitor hook for dev use, and automated benchmark tests asserting render timing budgets.
</objective>

<execution_context>
@/Users/tarikstafford/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tarikstafford/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-performance-quality/05-RESEARCH.md

@src/components/pet-svg/AnimatedPetSVG.tsx
@src/components/pet-svg/PetSVG.tsx
@src/lib/traits/generation.ts
@src/lib/traits/types.ts
@vitest.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Memoize AnimatedPetSVG and create useFPSMonitor hook</name>
  <files>
    src/components/pet-svg/AnimatedPetSVG.tsx
    src/hooks/useFPSMonitor.ts
  </files>
  <action>
1. **Wrap AnimatedPetSVG in React.memo** in `src/components/pet-svg/AnimatedPetSVG.tsx`:
   - Convert the current `AnimatedPetSVG` component to use `React.memo` with a custom comparison function
   - The comparison function should compare `petId` (string equality), `traits` (JSON.stringify deep compare, matching PetSVG pattern), `size` (string equality), and skip `className` (cosmetic)
   - Keep the existing function body unchanged -- only add the memo wrapper
   - Export pattern: `export const AnimatedPetSVG = React.memo(AnimatedPetSVGComponent, arePropsEqual);` (matching PetSVG's pattern)
   - This prevents parent re-renders from causing unnecessary re-renders of the animation wrapper when props haven't changed

2. **Create `src/hooks/useFPSMonitor.ts`**:
   - Implement the useFPSMonitor hook from the research (sliding window requestAnimationFrame pattern)
   - Track frame timestamps in a ref, count frames in last 1 second
   - Return current FPS as a number (default 60)
   - Guard with `process.env.NODE_ENV !== 'development'` check -- return 60 immediately in production
   - Clean up requestAnimationFrame on unmount via cleanup return
   - Do NOT create the DevFPSOverlay component (that's a nice-to-have, not a requirement)
  </action>
  <verify>
    - `npx tsc --noEmit` passes (no TypeScript errors)
    - `npm test` passes (existing tests not broken)
    - Grep confirms `React.memo` in AnimatedPetSVG.tsx: `grep 'React.memo' src/components/pet-svg/AnimatedPetSVG.tsx`
    - Grep confirms useFPSMonitor export: `grep 'export.*useFPSMonitor' src/hooks/useFPSMonitor.ts`
  </verify>
  <done>
    - AnimatedPetSVG is wrapped in React.memo with custom arePropsEqual comparing petId, traits, and size
    - useFPSMonitor hook exists and exports a function returning FPS number
    - All existing tests pass with zero regressions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create performance benchmark test suite</name>
  <files>
    src/__tests__/performance/render-benchmark.spec.ts
  </files>
  <action>
Create `src/__tests__/performance/render-benchmark.spec.ts` with the following test suite:

**File naming:** Use `.spec.ts` extension per codebase convention (NOT `.test.ts`).

**Imports needed:**
- `{ render } from '@testing-library/react'`
- `React, { Profiler, ProfilerOnRenderCallback } from 'react'`
- `{ generatePetTraits } from '@/lib/traits/generation'`
- `{ AnimatedPetSVG } from '@/components/pet-svg'`
- `{ PetSVG } from '@/components/pet-svg'`
- `{ describe, it, expect } from 'vitest'`

**Test 1 -- PERF-01: Single pet render timing**
```
describe('PERF-01: Single pet rendering', () => {
  it('completes initial mount in under 16ms', () => {
    const renderTimings: number[] = [];
    const traits = generatePetTraits('perf-test-single');

    const onRender: ProfilerOnRenderCallback = (id, phase, actualDuration) => {
      renderTimings.push(actualDuration);
    };

    render(
      <Profiler id="single-pet" onRender={onRender}>
        <AnimatedPetSVG petId="perf-test-single" traits={traits} size="medium" />
      </Profiler>
    );

    expect(renderTimings.length).toBeGreaterThan(0);
    expect(Math.max(...renderTimings)).toBeLessThan(16);
  });
});
```

**Test 2 -- PERF-02: Trait generation timing**
```
describe('PERF-02: Trait generation performance', () => {
  it('generates traits in under 10ms per pet', () => {
    const iterations = 100;
    const start = performance.now();

    for (let i = 0; i < iterations; i++) {
      generatePetTraits(`perf-gen-${i}`);
    }

    const elapsed = performance.now() - start;
    const avgPerPet = elapsed / iterations;

    expect(avgPerPet).toBeLessThan(10);
  });
});
```

**Test 3 -- PERF-03: Multiple pets render timing**
```
describe('PERF-03: Multiple pet rendering', () => {
  it('renders 10 simultaneous pets with each under 16ms', () => {
    const renderTimings: Map<string, number[]> = new Map();

    const pets = Array.from({ length: 10 }, (_, i) => ({
      id: `perf-multi-${i}`,
      traits: generatePetTraits(`perf-multi-${i}`)
    }));

    const onRender: ProfilerOnRenderCallback = (id, phase, actualDuration) => {
      if (!renderTimings.has(id)) renderTimings.set(id, []);
      renderTimings.get(id)!.push(actualDuration);
    };

    render(
      <div>
        {pets.map(pet => (
          <Profiler key={pet.id} id={pet.id} onRender={onRender}>
            <AnimatedPetSVG petId={pet.id} traits={pet.traits} size="medium" />
          </Profiler>
        ))}
      </div>
    );

    // Each individual pet should render in under 16ms
    for (const [id, timings] of renderTimings) {
      expect(Math.max(...timings)).toBeLessThan(16);
    }

    // Verify all 10 pets were rendered
    expect(renderTimings.size).toBe(10);
  });
});
```

**Test 4 -- PERF-05: Page load overhead**
```
describe('PERF-05: Page load overhead', () => {
  it('10 pets add less than 100ms total render overhead', () => {
    const pets = Array.from({ length: 10 }, (_, i) => ({
      id: `perf-load-${i}`,
      traits: generatePetTraits(`perf-load-${i}`)
    }));

    let totalDuration = 0;
    const onRender: ProfilerOnRenderCallback = (id, phase, actualDuration) => {
      if (phase === 'mount') {
        totalDuration += actualDuration;
      }
    };

    render(
      <Profiler id="page-load" onRender={onRender}>
        <div>
          {pets.map(pet => (
            <AnimatedPetSVG key={pet.id} petId={pet.id} traits={pet.traits} size="medium" />
          ))}
        </div>
      </Profiler>
    );

    expect(totalDuration).toBeLessThan(100);
  });
});
```

**Test 5 -- React.memo prevents unnecessary re-renders**
```
describe('React.memo optimization', () => {
  it('AnimatedPetSVG does not re-render when parent re-renders with same props', () => {
    let renderCount = 0;
    const traits = generatePetTraits('memo-test');

    const onRender: ProfilerOnRenderCallback = (id, phase, actualDuration) => {
      renderCount++;
    };

    const { rerender } = render(
      <Profiler id="memo-test" onRender={onRender}>
        <AnimatedPetSVG petId="memo-test" traits={traits} size="medium" />
      </Profiler>
    );

    const initialRenderCount = renderCount;

    // Re-render with identical props (new object references but same values)
    rerender(
      <Profiler id="memo-test" onRender={onRender}>
        <AnimatedPetSVG petId="memo-test" traits={{...traits}} size="medium" />
      </Profiler>
    );

    // React.memo should prevent re-render since arePropsEqual uses JSON.stringify
    expect(renderCount).toBe(initialRenderCount);
  });
});
```

**Important notes:**
- Use jsdom environment (already configured in vitest.config.ts)
- Performance timings in jsdom will be faster than browser -- thresholds are generous enough for both
- All tests must be deterministic (seeded IDs produce same traits)
  </action>
  <verify>
    - `npm test -- src/__tests__/performance/render-benchmark.spec.ts` passes with all tests green
    - `npm test` passes (full test suite including new tests)
  </verify>
  <done>
    - Performance benchmark test file exists at src/__tests__/performance/render-benchmark.spec.ts
    - Contains 5 test cases covering PERF-01 (single pet <16ms), PERF-02 (generation <10ms), PERF-03 (10 pets each <16ms), PERF-05 (total overhead <100ms), and memo optimization verification
    - All tests pass
  </done>
</task>

</tasks>

<verification>
- `npm test` passes with all tests (existing + new benchmark tests)
- `npx tsc --noEmit` shows no TypeScript errors
- AnimatedPetSVG uses React.memo (grep confirms)
- Performance benchmarks all pass within budget
</verification>

<success_criteria>
- PERF-01: Single pet render confirmed under 16ms by automated test
- PERF-02: Trait generation confirmed under 10ms by automated test
- PERF-03: 10 simultaneous pets confirmed under 16ms each by automated test
- PERF-05: Total page load overhead for 10 pets confirmed under 100ms by automated test
- AnimatedPetSVG memoization prevents unnecessary re-renders (confirmed by test)
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/05-performance-quality/05-01-SUMMARY.md`
</output>
