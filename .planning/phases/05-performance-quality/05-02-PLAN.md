---
phase: 05-performance-quality
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/__tests__/quality/color-harmony.spec.ts
  - src/__tests__/quality/visual-distinctiveness.spec.ts
autonomous: true

must_haves:
  truths:
    - "Color combinations pass aesthetic validation across 1000+ randomly generated pets"
    - "No two pets with different IDs produce identical trait combinations"
    - "Users can visually distinguish pets from each other at a glance"
  artifacts:
    - path: "src/__tests__/quality/color-harmony.spec.ts"
      provides: "Mass color harmony validation for QUALITY-01"
      contains: "validateColorHarmony"
    - path: "src/__tests__/quality/visual-distinctiveness.spec.ts"
      provides: "Trait uniqueness and distribution validation for QUALITY-02"
      contains: "generatePetTraits"
  key_links:
    - from: "src/__tests__/quality/color-harmony.spec.ts"
      to: "src/lib/traits/colorHarmony.ts"
      via: "Direct import of validateColorHarmony"
      pattern: "validateColorHarmony"
    - from: "src/__tests__/quality/color-harmony.spec.ts"
      to: "src/lib/traits/generation.ts"
      via: "Mass generation of pet traits for sampling"
      pattern: "generatePetTraits"
    - from: "src/__tests__/quality/visual-distinctiveness.spec.ts"
      to: "src/lib/traits/generation.ts"
      via: "Generating traits for uniqueness comparison"
      pattern: "generatePetTraits"
---

<objective>
Create automated quality validation test suites that prove color harmony (QUALITY-01) and visual distinctiveness (QUALITY-02) across large sample sizes.

Purpose: The trait generation system uses HSL constraints (saturation 50-90%, lightness 25-75%) and complementary color generation to prevent clashing. These tests formally validate that these constraints hold across 1000+ samples and that pets are visually distinguishable from each other.

Output: Two test files validating color quality and trait uniqueness at scale.
</objective>

<execution_context>
@/Users/tarikstafford/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tarikstafford/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-performance-quality/05-RESEARCH.md

@src/lib/traits/generation.ts
@src/lib/traits/colorHarmony.ts
@src/lib/traits/types.ts
@src/lib/traits/validation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create color harmony mass validation test suite (QUALITY-01)</name>
  <files>
    src/__tests__/quality/color-harmony.spec.ts
  </files>
  <action>
Create `src/__tests__/quality/color-harmony.spec.ts` with the following test suite.

**File naming:** Use `.spec.ts` extension per codebase convention.

**Imports:**
- `{ generatePetTraits } from '@/lib/traits/generation'`
- `{ validateColorHarmony, hslToString } from '@/lib/traits/colorHarmony'`
- `{ describe, it, expect } from 'vitest'`
- `type { HSLColor } from '@/lib/traits/types'`

**Test 1 -- QUALITY-01: Mass color harmony validation (1000+ samples)**
```
describe('QUALITY-01: Color combination harmony', () => {
  it('validates harmony across 1000+ random pet samples', () => {
    const sampleSize = 1500; // Exceeds 1000+ requirement
    const failures: string[] = [];

    for (let i = 0; i < sampleSize; i++) {
      const petId = `quality-color-${i}`;
      const traits = generatePetTraits(petId);

      const colors: HSLColor[] = [traits.bodyColor];
      if (traits.patternColor) {
        colors.push(traits.patternColor);
      }

      const isValid = validateColorHarmony(colors);
      if (!isValid) {
        failures.push(
          `Pet ${petId}: ${colors.map(hslToString).join(' + ')} (rarity: ${traits.rarity})`
        );
      }
    }

    // Log failures for debugging if any exist
    if (failures.length > 0) {
      console.error(`Color harmony failures (${failures.length}/${sampleSize}):`);
      failures.forEach(f => console.error(`  ${f}`));
    }

    // QUALITY-01: Zero clashing colors across entire sample
    expect(failures).toHaveLength(0);
  });
});
```

**Test 2 -- HSL constraint boundaries**
```
describe('QUALITY-01: HSL constraint enforcement', () => {
  it('all body colors fall within saturation 50-90% and lightness 25-75%', () => {
    const sampleSize = 1000;
    const violations: string[] = [];

    for (let i = 0; i < sampleSize; i++) {
      const petId = `quality-hsl-${i}`;
      const traits = generatePetTraits(petId);
      const c = traits.bodyColor;

      if (c.s < 50 || c.s > 90) {
        violations.push(`Pet ${petId}: saturation ${c.s.toFixed(1)}% out of range [50, 90]`);
      }
      if (c.l < 25 || c.l > 75) {
        violations.push(`Pet ${petId}: lightness ${c.l.toFixed(1)}% out of range [25, 75]`);
      }
    }

    expect(violations).toHaveLength(0);
  });

  it('pattern colors maintain harmony with body colors', () => {
    const sampleSize = 1000;
    const petsWithPatterns: Array<{ petId: string; bodyColor: HSLColor; patternColor: HSLColor }> = [];

    for (let i = 0; i < sampleSize; i++) {
      const petId = `quality-pattern-${i}`;
      const traits = generatePetTraits(petId);

      if (traits.patternColor && traits.patternType !== 'none') {
        petsWithPatterns.push({
          petId,
          bodyColor: traits.bodyColor,
          patternColor: traits.patternColor
        });
      }
    }

    // Should have a significant number of patterned pets (most pets have patterns)
    expect(petsWithPatterns.length).toBeGreaterThan(100);

    // All pattern colors should pass harmony check with body color
    const failures = petsWithPatterns.filter(p =>
      !validateColorHarmony([p.bodyColor, p.patternColor])
    );

    expect(failures).toHaveLength(0);
  });
});
```

**Test 3 -- No muddy or extreme colors**
```
describe('QUALITY-01: No muddy or extreme colors', () => {
  it('no pet has muddy colors (low saturation + mid lightness)', () => {
    const sampleSize = 1000;

    for (let i = 0; i < sampleSize; i++) {
      const traits = generatePetTraits(`quality-muddy-${i}`);
      const c = traits.bodyColor;

      // Muddy = saturation < 30 AND lightness between 40-60
      const isMuddy = c.s < 30 && c.l > 40 && c.l < 60;
      expect(isMuddy).toBe(false);
    }
  });
});
```
  </action>
  <verify>
    - `npm test -- src/__tests__/quality/color-harmony.spec.ts` passes with all tests green
    - All 1500 sample harmony checks pass (zero failures)
    - All 1000 sample HSL constraint checks pass
  </verify>
  <done>
    - Color harmony test file exists at src/__tests__/quality/color-harmony.spec.ts
    - Contains 4 test cases: mass harmony validation (1500 samples), HSL constraint boundaries, pattern-body harmony, and muddy color rejection
    - QUALITY-01 requirement validated: zero clashing colors across 1500 samples
  </done>
</task>

<task type="auto">
  <name>Task 2: Create visual distinctiveness validation test suite (QUALITY-02)</name>
  <files>
    src/__tests__/quality/visual-distinctiveness.spec.ts
  </files>
  <action>
Create `src/__tests__/quality/visual-distinctiveness.spec.ts` with the following test suite.

**File naming:** Use `.spec.ts` extension per codebase convention.

**Imports:**
- `{ generatePetTraits } from '@/lib/traits/generation'`
- `{ describe, it, expect } from 'vitest'`
- `type { PetTraits } from '@/lib/traits/types'`

**Test 1 -- QUALITY-02: No duplicate trait combinations**
```
describe('QUALITY-02: Visual distinctiveness', () => {
  it('no two pets produce identical trait combinations across 1000 samples', () => {
    const sampleSize = 1000;
    const traitSignatures = new Map<string, string>();
    const duplicates: Array<{ petId1: string; petId2: string; signature: string }> = [];

    for (let i = 0; i < sampleSize; i++) {
      const petId = `distinct-${i}`;
      const traits = generatePetTraits(petId);

      // Create a visual signature from all visible trait properties
      const signature = [
        `body:${Math.round(traits.bodyColor.h)}-${Math.round(traits.bodyColor.s)}-${Math.round(traits.bodyColor.l)}`,
        `pattern:${traits.patternType}`,
        traits.patternColor
          ? `patternColor:${Math.round(traits.patternColor.h)}-${Math.round(traits.patternColor.s)}-${Math.round(traits.patternColor.l)}`
          : 'patternColor:none',
        `accessory:${traits.accessory}`,
        `size:${traits.bodySize}`,
        `expression:${traits.expression}`
      ].join('|');

      if (traitSignatures.has(signature)) {
        duplicates.push({
          petId1: traitSignatures.get(signature)!,
          petId2: petId,
          signature
        });
      } else {
        traitSignatures.set(signature, petId);
      }
    }

    if (duplicates.length > 0) {
      console.error(`Duplicate trait signatures found (${duplicates.length}):`);
      duplicates.forEach(d => console.error(`  ${d.petId1} == ${d.petId2}: ${d.signature}`));
    }

    // Zero exact duplicates across 1000 samples
    expect(duplicates).toHaveLength(0);
  });
});
```

**Test 2 -- QUALITY-02: Body color diversity (hue distribution)**
```
describe('QUALITY-02: Color diversity', () => {
  it('body colors span at least 300 degrees of the hue wheel across 1000 samples', () => {
    const sampleSize = 1000;
    const hues: number[] = [];

    for (let i = 0; i < sampleSize; i++) {
      const traits = generatePetTraits(`diversity-hue-${i}`);
      hues.push(traits.bodyColor.h);
    }

    const minHue = Math.min(...hues);
    const maxHue = Math.max(...hues);
    const hueSpread = maxHue - minHue;

    // With 1000 random samples across 0-360, spread should be at least 300
    expect(hueSpread).toBeGreaterThan(300);
  });

  it('all body sizes appear with roughly equal frequency', () => {
    const sampleSize = 1000;
    const sizeCounts = { small: 0, medium: 0, large: 0 };

    for (let i = 0; i < sampleSize; i++) {
      const traits = generatePetTraits(`diversity-size-${i}`);
      sizeCounts[traits.bodySize]++;
    }

    // Each size should appear at least 20% of the time (expected ~33%)
    const minExpected = sampleSize * 0.2;
    expect(sizeCounts.small).toBeGreaterThan(minExpected);
    expect(sizeCounts.medium).toBeGreaterThan(minExpected);
    expect(sizeCounts.large).toBeGreaterThan(minExpected);
  });

  it('all expression types appear in sample', () => {
    const sampleSize = 1000;
    const expressions = new Set<string>();

    for (let i = 0; i < sampleSize; i++) {
      const traits = generatePetTraits(`diversity-expr-${i}`);
      expressions.add(traits.expression);
    }

    // All 5 expression types should appear
    expect(expressions.size).toBe(5);
    expect(expressions.has('happy')).toBe(true);
    expect(expressions.has('neutral')).toBe(true);
    expect(expressions.has('curious')).toBe(true);
    expect(expressions.has('mischievous')).toBe(true);
    expect(expressions.has('sleepy')).toBe(true);
  });
});
```

**Test 3 -- QUALITY-02: Rarity distribution validation**
```
describe('QUALITY-02: Rarity distribution', () => {
  it('rarity tiers follow 70/20/8/2 distribution within tolerance', () => {
    const sampleSize = 10000; // Large sample for distribution accuracy
    const rarityCounts = { common: 0, uncommon: 0, rare: 0, legendary: 0 };

    for (let i = 0; i < sampleSize; i++) {
      const traits = generatePetTraits(`rarity-dist-${i}`);
      rarityCounts[traits.rarity]++;
    }

    const tolerance = 0.03; // 3% tolerance for randomness

    expect(rarityCounts.common / sampleSize).toBeCloseTo(0.70, 1);
    expect(rarityCounts.uncommon / sampleSize).toBeCloseTo(0.20, 1);
    expect(rarityCounts.rare / sampleSize).toBeGreaterThan(0.08 - tolerance);
    expect(rarityCounts.rare / sampleSize).toBeLessThan(0.08 + tolerance);
    expect(rarityCounts.legendary / sampleSize).toBeGreaterThan(0.02 - tolerance);
    expect(rarityCounts.legendary / sampleSize).toBeLessThan(0.02 + tolerance);
  });
});
```

**Test 4 -- QUALITY-02: Adjacent pets in a grid are distinguishable**
```
describe('QUALITY-02: Adjacent pet distinguishability', () => {
  it('consecutive pet IDs produce visually different pets', () => {
    // Simulate a grid where pet IDs might be sequential
    for (let i = 0; i < 100; i++) {
      const traits1 = generatePetTraits(`pet-${i}`);
      const traits2 = generatePetTraits(`pet-${i + 1}`);

      // At least one major visual trait must differ
      const colorDiff = Math.abs(traits1.bodyColor.h - traits2.bodyColor.h);
      const patternDiff = traits1.patternType !== traits2.patternType;
      const accessoryDiff = traits1.accessory !== traits2.accessory;
      const sizeDiff = traits1.bodySize !== traits2.bodySize;
      const expressionDiff = traits1.expression !== traits2.expression;

      // At least ONE of these must be true for visual distinction
      const isDistinguishable =
        colorDiff > 30 || // Hue differs by more than 30 degrees (noticeable)
        patternDiff ||
        accessoryDiff ||
        sizeDiff ||
        expressionDiff;

      expect(isDistinguishable).toBe(true);
    }
  });
});
```
  </action>
  <verify>
    - `npm test -- src/__tests__/quality/visual-distinctiveness.spec.ts` passes with all tests green
    - Zero duplicate trait signatures across 1000 samples
    - Hue spread exceeds 300 degrees
    - Rarity distribution matches expected 70/20/8/2 pattern
  </verify>
  <done>
    - Visual distinctiveness test file exists at src/__tests__/quality/visual-distinctiveness.spec.ts
    - Contains 6 test cases: no duplicates, hue diversity, size distribution, expression coverage, rarity distribution, adjacent distinguishability
    - QUALITY-02 requirement validated: pets are visually distinct from each other at a glance
  </done>
</task>

</tasks>

<verification>
- `npm test` passes with all tests (existing + new quality tests)
- Color harmony holds across 1500 samples with zero failures
- No duplicate trait combinations in 1000 samples
- All trait types and rarities represented in expected distributions
</verification>

<success_criteria>
- QUALITY-01: Zero color harmony failures across 1500 samples
- QUALITY-02: Zero duplicate trait signatures across 1000 samples
- QUALITY-02: Full hue wheel coverage (>300 degrees), all sizes/expressions represented
- QUALITY-02: Adjacent pets always visually distinguishable
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/05-performance-quality/05-02-SUMMARY.md`
</output>
